/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_obsidian3 = require("obsidian");

// src/constants.ts
var isLocalMode = process.env.NODE_ENV === "local";
var BASE_URL = "https://line-to-obsidian.line-to-obsidian.workers.dev";
if (!BASE_URL && process.env.NODE_ENV === "development") {
  console.error("\u8B66\u544A: OBSIDIAN_LINE_API_URL\u304C\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002API\u3068\u306E\u901A\u4FE1\u304C\u3067\u304D\u307E\u305B\u3093\u3002");
}
var API_ENDPOINTS = {
  BASE_URL,
  MESSAGES: (vaultId, userId) => {
    if (!vaultId || !userId) {
      throw new Error("vaultId\u3068userId\u306F\u5FC5\u9808\u30D1\u30E9\u30E1\u30FC\u30BF\u3067\u3059");
    }
    return `${BASE_URL}/messages/${vaultId}/${userId}`;
  },
  MAPPING: `${BASE_URL}/mapping`,
  UPDATE_SYNC_STATUS: `${BASE_URL}/messages/update-sync-status`,
  REGISTER_PUBLIC_KEY: `${BASE_URL}/publickey/register`,
  GET_PUBLIC_KEY: (userId) => `${BASE_URL}/publickey/${userId}`
};

// src/crypto/cryptoUtils.ts
var CryptoUtils = class {
  /**
   * RSA鍵ペアを生成
   */
  static async generateKeyPair() {
    return await crypto.subtle.generateKey(
      {
        name: "RSA-OAEP",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: "SHA-256"
      },
      true,
      ["encrypt", "decrypt"]
    );
  }
  /**
   * AES鍵を生成
   */
  static async generateAESKey() {
    return await crypto.subtle.generateKey(
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
  }
  /**
   * 公開鍵をPEM形式にエクスポート
   */
  static async exportPublicKey(publicKey) {
    var _a;
    const exported = await crypto.subtle.exportKey("spki", publicKey);
    const exportedAsString = String.fromCharCode.apply(null, Array.from(new Uint8Array(exported)));
    const exportedAsBase64 = btoa(exportedAsString);
    return `-----BEGIN PUBLIC KEY-----
${(_a = exportedAsBase64.match(/.{1,64}/g)) == null ? void 0 : _a.join("\n")}
-----END PUBLIC KEY-----`;
  }
  /**
   * 秘密鍵をPEM形式にエクスポート
   */
  static async exportPrivateKey(privateKey) {
    var _a;
    const exported = await crypto.subtle.exportKey("pkcs8", privateKey);
    const exportedAsString = String.fromCharCode.apply(null, Array.from(new Uint8Array(exported)));
    const exportedAsBase64 = btoa(exportedAsString);
    return `-----BEGIN PRIVATE KEY-----
${(_a = exportedAsBase64.match(/.{1,64}/g)) == null ? void 0 : _a.join("\n")}
-----END PRIVATE KEY-----`;
  }
  /**
   * PEM形式の公開鍵をインポート
   */
  static async importPublicKey(pem) {
    const pemHeader = "-----BEGIN PUBLIC KEY-----";
    const pemFooter = "-----END PUBLIC KEY-----";
    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length).replace(/\s/g, "");
    const binaryDerString = atob(pemContents);
    const binaryDer = new Uint8Array(Array.from(binaryDerString, (char) => char.charCodeAt(0)));
    return await crypto.subtle.importKey(
      "spki",
      binaryDer,
      {
        name: "RSA-OAEP",
        hash: "SHA-256"
      },
      true,
      ["encrypt"]
    );
  }
  /**
   * PEM形式の秘密鍵をインポート
   */
  static async importPrivateKey(pem) {
    const pemHeader = "-----BEGIN PRIVATE KEY-----";
    const pemFooter = "-----END PRIVATE KEY-----";
    const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length).replace(/\s/g, "");
    const binaryDerString = atob(pemContents);
    const binaryDer = new Uint8Array(Array.from(binaryDerString, (char) => char.charCodeAt(0)));
    return await crypto.subtle.importKey(
      "pkcs8",
      binaryDer,
      {
        name: "RSA-OAEP",
        hash: "SHA-256"
      },
      true,
      ["decrypt"]
    );
  }
  /**
   * メッセージをAES-GCMで暗号化
   */
  static async encryptMessage(message, aesKey) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      aesKey,
      this.encoder.encode(message)
    );
    return { encrypted, iv };
  }
  /**
   * AES-GCMで暗号化されたメッセージを復号化
   */
  static async decryptMessage(encrypted, aesKey, iv) {
    const decrypted = await crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv
      },
      aesKey,
      encrypted
    );
    return this.decoder.decode(decrypted);
  }
  /**
   * AES鍵をRSA公開鍵で暗号化
   */
  static async encryptAESKey(aesKey, publicKey) {
    const exportedKey = await crypto.subtle.exportKey("raw", aesKey);
    return await crypto.subtle.encrypt(
      {
        name: "RSA-OAEP"
      },
      publicKey,
      exportedKey
    );
  }
  /**
   * RSA秘密鍵で暗号化されたAES鍵を復号化
   */
  static async decryptAESKey(encryptedKey, privateKey) {
    let keyBuffer;
    if (encryptedKey === null || encryptedKey === void 0) {
      throw new Error("Encrypted key is null or undefined");
    }
    if (encryptedKey instanceof ArrayBuffer) {
      keyBuffer = encryptedKey;
    } else if (ArrayBuffer.isView(encryptedKey)) {
      const view = encryptedKey;
      keyBuffer = view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength);
    } else {
      keyBuffer = encryptedKey;
    }
    const decryptedKey = await crypto.subtle.decrypt(
      {
        name: "RSA-OAEP"
      },
      privateKey,
      keyBuffer
    );
    return await crypto.subtle.importKey(
      "raw",
      decryptedKey,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
  }
  /**
   * ArrayBufferをBase64文字列に変換
   */
  static arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  /**
   * Base64文字列をArrayBufferに変換
   */
  static base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
  }
  /**
   * デバイス固有のIDを生成（ブラウザフィンガープリント）
   */
  static async generateDeviceId() {
    const fingerprint = {
      userAgent: navigator.userAgent,
      language: navigator.language,
      platform: navigator.platform,
      hardwareConcurrency: navigator.hardwareConcurrency,
      timestamp: Date.now(),
      random: crypto.getRandomValues(new Uint8Array(16))
    };
    const data = this.encoder.encode(JSON.stringify(fingerprint));
    const hash = await crypto.subtle.digest("SHA-256", data);
    return this.arrayBufferToBase64(hash);
  }
  /**
   * デバイスIDから暗号化キーを派生
   */
  static async deriveKeyFromDeviceId(deviceId, salt) {
    if (!salt) {
      salt = crypto.getRandomValues(new Uint8Array(16));
    }
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      this.encoder.encode(deviceId),
      "PBKDF2",
      false,
      ["deriveBits", "deriveKey"]
    );
    return await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 1e5,
        hash: "SHA-256"
      },
      keyMaterial,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    );
  }
};
CryptoUtils.encoder = new TextEncoder();
CryptoUtils.decoder = new TextDecoder();

// src/crypto/keyManager.ts
var KeyManager = class {
  constructor(plugin) {
    this.deviceKey = null;
    this.keyPair = null;
    this.publicKeyCache = /* @__PURE__ */ new Map();
    this.CACHE_DURATION = 24 * 60 * 60 * 1e3;
    this.plugin = plugin;
  }
  async initialize() {
    const keys = await this.loadKeys();
    if (!keys) {
      await this.generateAndSaveKeys();
    } else {
      await this.loadExistingKeys(keys);
      const data = await this.plugin.loadData();
      if (data == null ? void 0 : data.pendingKeyRegistration) {
        await this.attemptKeyRegistration(keys);
      }
    }
  }
  async attemptKeyRegistration(keys) {
    const data = await this.plugin.loadData();
    const failureCount = data.registrationFailureCount || 0;
    const lastAttempt = data.lastRegistrationAttempt || 0;
    const backoffHours = Math.min(Math.pow(2, failureCount), 24);
    const backoffMs = backoffHours * 60 * 60 * 1e3;
    const timeSinceLastAttempt = Date.now() - lastAttempt;
    if (timeSinceLastAttempt < backoffMs) {
      return;
    }
    try {
      await this.registerPublicKey(keys);
      delete data.pendingKeyRegistration;
      delete data.registrationFailureCount;
      delete data.lastRegistrationAttempt;
      await this.plugin.saveData(data);
      if (process.env.NODE_ENV === "development") {
        console.log("Public key registration completed successfully");
      }
    } catch (error) {
      data.pendingKeyRegistration = true;
      data.lastRegistrationAttempt = Date.now();
      data.registrationFailureCount = failureCount + 1;
      await this.plugin.saveData(data);
      if (process.env.NODE_ENV === "development") {
        console.error(
          `Public key registration failed (attempt ${failureCount + 1}):`,
          error
        );
      }
    }
  }
  async generateAndSaveKeys() {
    const deviceId = await CryptoUtils.generateDeviceId();
    this.keyPair = await CryptoUtils.generateKeyPair();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    this.deviceKey = await CryptoUtils.deriveKeyFromDeviceId(deviceId, salt);
    const privateKeyPem = await CryptoUtils.exportPrivateKey(this.keyPair.privateKey);
    const encryptedPrivateKey = await this.encryptPrivateKey(privateKeyPem);
    const publicKeyPem = await CryptoUtils.exportPublicKey(this.keyPair.publicKey);
    const keyInfo = {
      publicKey: publicKeyPem,
      encryptedPrivateKey: CryptoUtils.arrayBufferToBase64(encryptedPrivateKey),
      deviceId,
      keyId: crypto.randomUUID(),
      createdAt: Date.now(),
      salt: CryptoUtils.arrayBufferToBase64(salt)
    };
    await this.saveKeys(keyInfo);
    await this.registerPublicKey(keyInfo);
  }
  async loadExistingKeys(keys) {
    const salt = CryptoUtils.base64ToArrayBuffer(keys.salt);
    this.deviceKey = await CryptoUtils.deriveKeyFromDeviceId(keys.deviceId, new Uint8Array(salt));
    const encryptedPrivateKey = CryptoUtils.base64ToArrayBuffer(keys.encryptedPrivateKey);
    const privateKeyPem = await this.decryptPrivateKey(encryptedPrivateKey);
    const privateKey = await CryptoUtils.importPrivateKey(privateKeyPem);
    const publicKey = await CryptoUtils.importPublicKey(keys.publicKey);
    this.keyPair = {
      privateKey,
      publicKey
    };
  }
  async encryptPrivateKey(privateKeyPem) {
    if (!this.deviceKey)
      throw new Error("Device key not initialized");
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      this.deviceKey,
      new TextEncoder().encode(privateKeyPem)
    );
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv, 0);
    combined.set(new Uint8Array(encrypted), iv.length);
    return combined.buffer;
  }
  async decryptPrivateKey(encryptedData) {
    if (!this.deviceKey)
      throw new Error("Device key not initialized");
    const data = new Uint8Array(encryptedData);
    const iv = data.slice(0, 12);
    const encrypted = data.slice(12);
    const decrypted = await crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv
      },
      this.deviceKey,
      encrypted
    );
    return new TextDecoder().decode(decrypted);
  }
  async saveKeys(keys) {
    await this.plugin.saveData({
      ...await this.plugin.loadData(),
      encryptionKeys: keys
    });
  }
  async loadKeys() {
    const data = await this.plugin.loadData();
    return (data == null ? void 0 : data.encryptionKeys) || null;
  }
  async registerPublicKey(keyInfo) {
    const settings = await this.plugin.loadData();
    try {
      const { requestUrl: requestUrl2 } = require("obsidian");
      const response = await requestUrl2({
        url: API_ENDPOINTS.REGISTER_PUBLIC_KEY,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          userId: settings.lineUserId,
          vaultId: settings.vaultId,
          publicKey: keyInfo.publicKey,
          keyId: keyInfo.keyId
        })
      });
      if (response.status !== 200) {
        throw new Error(`Failed to register public key: ${response.status}`);
      }
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("Failed to register public key:", error);
      }
      const data = await this.plugin.loadData();
      data.pendingKeyRegistration = true;
      data.lastRegistrationAttempt = Date.now();
      data.registrationFailureCount = (data.registrationFailureCount || 0) + 1;
      await this.plugin.saveData(data);
      throw error;
    }
  }
  async getPublicKey(userId) {
    const cached = this.publicKeyCache.get(userId);
    if (cached && Date.now() - cached.fetchedAt < this.CACHE_DURATION) {
      return await CryptoUtils.importPublicKey(cached.publicKey);
    }
    const settings = await this.plugin.loadData();
    const { requestUrl: requestUrl2 } = require("obsidian");
    const response = await requestUrl2({
      url: API_ENDPOINTS.GET_PUBLIC_KEY(userId),
      method: "GET",
      headers: {
        "X-Vault-Id": settings.vaultId
      }
    });
    if (response.status !== 200) {
      throw new Error(`Failed to fetch public key for user ${userId}`);
    }
    const data = JSON.parse(response.text);
    this.publicKeyCache.set(userId, {
      userId,
      publicKey: data.publicKey,
      keyId: data.keyId,
      fetchedAt: Date.now()
    });
    return await CryptoUtils.importPublicKey(data.publicKey);
  }
  getKeyPair() {
    if (!this.keyPair) {
      throw new Error("Key pair not initialized");
    }
    return this.keyPair;
  }
  clearPublicKeyCache() {
    this.publicKeyCache.clear();
  }
  clearPublicKeyForUser(userId) {
    this.publicKeyCache.delete(userId);
  }
  async forceRegisterPublicKey() {
    const keys = await this.loadKeys();
    if (!keys) {
      throw new Error("No keys found to register");
    }
    await this.registerPublicKey(keys);
  }
};

// src/crypto/messageEncryptor.ts
var MessageEncryptor = class {
  constructor(keyManager) {
    this.VERSION = "1.0";
    this.keyManager = keyManager;
  }
  /**
   * Encrypts a message for a specific recipient
   */
  async encryptMessage(message, recipientUserId) {
    try {
      const recipientPublicKey = await this.keyManager.getPublicKey(recipientUserId);
      const aesKey = await CryptoUtils.generateAESKey();
      const { encrypted, iv } = await CryptoUtils.encryptMessage(message, aesKey);
      const encryptedAESKey = await CryptoUtils.encryptAESKey(aesKey, recipientPublicKey);
      const keyPair = this.keyManager.getKeyPair();
      const publicKeyPem = await CryptoUtils.exportPublicKey(keyPair.publicKey);
      const senderKeyId = await this.generateKeyId(publicKeyPem);
      return {
        encryptedContent: CryptoUtils.arrayBufferToBase64(encrypted),
        encryptedAESKey: CryptoUtils.arrayBufferToBase64(encryptedAESKey),
        iv: CryptoUtils.arrayBufferToBase64(iv),
        senderKeyId,
        recipientUserId,
        timestamp: Date.now(),
        version: this.VERSION
      };
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("Encryption failed:", error);
      }
      throw new Error("Failed to encrypt message");
    }
  }
  /**
   * Decrypts an encrypted message
   */
  async decryptMessage(encryptedMessage) {
    try {
      if (encryptedMessage.version !== this.VERSION) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Message version mismatch: expected ${this.VERSION}, got ${encryptedMessage.version}`);
        }
      }
      const keyPair = this.keyManager.getKeyPair();
      const encryptedContent = CryptoUtils.base64ToArrayBuffer(encryptedMessage.encryptedContent);
      const encryptedAESKey = CryptoUtils.base64ToArrayBuffer(encryptedMessage.encryptedAESKey);
      const iv = new Uint8Array(CryptoUtils.base64ToArrayBuffer(encryptedMessage.iv));
      const aesKey = await CryptoUtils.decryptAESKey(encryptedAESKey, keyPair.privateKey);
      const decrypted = await CryptoUtils.decryptMessage(encryptedContent, aesKey, iv);
      return decrypted;
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("Decryption failed:", error);
      }
      throw new Error("Failed to decrypt message");
    }
  }
  /**
   * Type guard for encrypted messages
   */
  isEncryptedMessage(message) {
    return message && typeof message === "object" && typeof message.encryptedContent === "string" && typeof message.encryptedAESKey === "string" && typeof message.iv === "string" && typeof message.version === "string";
  }
  /**
   * Checks for legacy message format compatibility
   */
  isLegacyMessage(message) {
    return message && typeof message === "object" && typeof message.text === "string" && !this.isEncryptedMessage(message);
  }
  /**
   * Processes messages transparently regardless of format
   */
  async processMessage(message) {
    if (message.encrypted === true && message.encryptedContent) {
      try {
        const encryptedMessage = {
          encryptedContent: message.encryptedContent,
          encryptedAESKey: message.encryptedAESKey || message.encryptedAesKey,
          iv: message.iv,
          senderKeyId: message.senderKeyId,
          recipientUserId: message.recipientUserId,
          timestamp: message.timestamp,
          version: message.version || "1.0"
        };
        return await this.decryptMessage(encryptedMessage);
      } catch (error) {
        if (process.env.NODE_ENV === "development") {
          console.error("Failed to decrypt message:", error);
        }
        return "[\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F]";
      }
    } else if (this.isLegacyMessage(message)) {
      return message.text;
    } else if (typeof message === "string") {
      return message;
    } else {
      if (process.env.NODE_ENV === "development") {
        console.warn("Unknown message format:", message);
      }
      return JSON.stringify(message);
    }
  }
  /**
   * Generates a unique key identifier
   */
  async generateKeyId(publicKeyPem) {
    const encoder = new TextEncoder();
    const data = encoder.encode(publicKeyPem);
    const hash = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hash));
    return hashArray.slice(0, 8).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  /**
   * Efficiently encrypts multiple messages for the same recipient
   */
  async encryptBatch(messages, recipientUserId) {
    const recipientPublicKey = await this.keyManager.getPublicKey(recipientUserId);
    const encryptedMessages = await Promise.all(
      messages.map((message) => this.encryptMessageWithKey(message, recipientPublicKey, recipientUserId))
    );
    return encryptedMessages;
  }
  /**
   * Internal method for message encryption
   */
  async encryptMessageWithKey(message, recipientPublicKey, recipientUserId) {
    const aesKey = await CryptoUtils.generateAESKey();
    const { encrypted, iv } = await CryptoUtils.encryptMessage(message, aesKey);
    const encryptedAESKey = await CryptoUtils.encryptAESKey(aesKey, recipientPublicKey);
    const keyPair = this.keyManager.getKeyPair();
    const publicKeyPem = await CryptoUtils.exportPublicKey(keyPair.publicKey);
    const senderKeyId = await this.generateKeyId(publicKeyPem);
    return {
      encryptedContent: CryptoUtils.arrayBufferToBase64(encrypted),
      encryptedAESKey: CryptoUtils.arrayBufferToBase64(encryptedAESKey),
      iv: CryptoUtils.arrayBufferToBase64(iv),
      senderKeyId,
      recipientUserId,
      timestamp: Date.now(),
      version: this.VERSION
    };
  }
};

// src/crypto/errorHandler.ts
var import_obsidian = require("obsidian");
var E2EEError = class extends Error {
  constructor(type, message, originalError) {
    super(message);
    this.type = type;
    this.originalError = originalError;
    this.name = "E2EEError";
  }
};
var E2EEErrorHandler = class {
  constructor(keyManager, messageEncryptor) {
    this.retryAttempts = /* @__PURE__ */ new Map();
    this.MAX_RETRY_ATTEMPTS = 3;
    this.keyManager = keyManager;
    this.messageEncryptor = messageEncryptor;
  }
  /**
   * Main error handling entry point
   */
  async handleError(error, context) {
    if (process.env.NODE_ENV === "development") {
      console.error(`E2EE Error in ${context}:`, error);
    }
    if (error instanceof E2EEError) {
      switch (error.type) {
        case "KEY_NOT_INITIALIZED" /* KEY_NOT_INITIALIZED */:
          return await this.handleKeyNotInitialized();
        case "KEY_NOT_FOUND" /* KEY_NOT_FOUND */:
          return await this.handleKeyNotFound(error);
        case "DECRYPTION_FAILED" /* DECRYPTION_FAILED */:
          return await this.handleDecryptionFailed(error);
        case "PUBLIC_KEY_FETCH_FAILED" /* PUBLIC_KEY_FETCH_FAILED */:
          return await this.handlePublicKeyFetchFailed(error);
        case "NETWORK_ERROR" /* NETWORK_ERROR */:
          return await this.handleNetworkError(error);
        default:
          return this.handleGenericError(error);
      }
    }
    return this.handleGenericError(error);
  }
  /**
   * Handles uninitialized key scenarios
   */
  async handleKeyNotInitialized() {
    try {
      await this.keyManager.initialize();
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("Failed to initialize keys:", error);
      }
      new import_obsidian.Notice("\u63A5\u7D9A\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u8A2D\u5B9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002");
      throw new E2EEError(
        "KEY_GENERATION_FAILED" /* KEY_GENERATION_FAILED */,
        "Failed to initialize encryption keys",
        error
      );
    }
  }
  /**
   * Handles missing key scenarios with retry logic
   */
  async handleKeyNotFound(error) {
    const userId = this.extractUserIdFromError(error);
    if (!userId) {
      throw error;
    }
    const retryKey = `key_not_found_${userId}`;
    const attempts = this.retryAttempts.get(retryKey) || 0;
    if (attempts < this.MAX_RETRY_ATTEMPTS) {
      this.retryAttempts.set(retryKey, attempts + 1);
      this.keyManager.clearPublicKeyForUser(userId);
      try {
        await this.keyManager.getPublicKey(userId);
        this.retryAttempts.delete(retryKey);
        return;
      } catch (retryError) {
        if (attempts + 1 >= this.MAX_RETRY_ATTEMPTS) {
          this.retryAttempts.delete(retryKey);
          throw new E2EEError(
            "PUBLIC_KEY_FETCH_FAILED" /* PUBLIC_KEY_FETCH_FAILED */,
            `Failed to fetch public key for user ${userId} after ${this.MAX_RETRY_ATTEMPTS} attempts`,
            retryError
          );
        }
      }
    }
  }
  /**
   * Handles decryption failures gracefully
   */
  async handleDecryptionFailed(error) {
    if (process.env.NODE_ENV === "development") {
      console.error("Decryption failed:", error);
    }
    return "[\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F]";
  }
  /**
   * Handles public key fetch failures
   */
  async handlePublicKeyFetchFailed(error) {
    const userId = this.extractUserIdFromError(error);
    if (userId) {
      await this.markUserAsOffline(userId);
    }
    throw error;
  }
  /**
   * Handles network-related errors
   */
  async handleNetworkError(error) {
    new import_obsidian.Notice("\u30CD\u30C3\u30C8\u30EF\u30FC\u30AF\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\u30A4\u30F3\u30BF\u30FC\u30CD\u30C3\u30C8\u63A5\u7D9A\u3092\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002");
    throw error;
  }
  /**
   * Handles unexpected errors
   */
  handleGenericError(error) {
    if (process.env.NODE_ENV === "development") {
      console.error("Unexpected E2EE error:", error);
    }
    new import_obsidian.Notice("\u51E6\u7406\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F");
    throw error;
  }
  /**
   * Extracts user ID from error messages
   */
  extractUserIdFromError(error) {
    const match = error.message.match(/user\s+(\w+)/i);
    return match ? match[1] : null;
  }
  /**
   * Checks if decryption error was recently shown
   */
  hasShownDecryptionError() {
    const lastShown = localStorage.getItem("line_plugin_error_shown");
    if (!lastShown)
      return false;
    const lastShownTime = parseInt(lastShown);
    const now = Date.now();
    return now - lastShownTime < 60 * 60 * 1e3;
  }
  /**
   * Records when decryption error was shown
   */
  markDecryptionErrorShown() {
    localStorage.setItem("line_plugin_error_shown", Date.now().toString());
  }
  /**
   * Marks a user as offline in local storage
   */
  async markUserAsOffline(userId) {
    const offlineUsers = JSON.parse(localStorage.getItem("line_plugin_offline_users") || "{}");
    offlineUsers[userId] = Date.now();
    localStorage.setItem("line_plugin_offline_users", JSON.stringify(offlineUsers));
  }
  /**
   * Clears all retry attempt counters
   */
  clearRetryCounters() {
    this.retryAttempts.clear();
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  noteFolderPath: "LINE",
  vaultId: "",
  lineUserId: "",
  autoSync: false,
  syncInterval: 2,
  syncOnStartup: false,
  organizeByDate: false,
  fileNameTemplate: "{date}-{messageId}",
  e2eeEnabled: true,
  groupMessagesByDate: false,
  groupedMessageTemplate: "{time}: {text}",
  groupedFrontmatterTemplate: "source: LINE\ndate: {date}",
  groupedFileNameTemplate: "{date}"
};
function parseMessageTemplate(template, message, messageText, getJSTTimeString) {
  return template.replace(/{time}/g, getJSTTimeString(message.timestamp)).replace(/{text}/g, messageText).replace(/{messageId}/g, message.messageId).replace(/{userId}/g, message.userId);
}
function parseFrontmatterTemplate(template, dateString) {
  return template.replace(/{date}/g, dateString.replace(/(\d{4})(\d{2})(\d{2})/, "$1-$2-$3")).replace(/{datecompact}/g, dateString);
}
var LinePlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
  }
  async onload() {
    await this.loadSettings();
    this.keyManager = new KeyManager(this);
    this.messageEncryptor = new MessageEncryptor(this.keyManager);
    this.errorHandler = new E2EEErrorHandler(this.keyManager, this.messageEncryptor);
    if (this.settings.lineUserId && this.settings.vaultId) {
      try {
        await this.keyManager.initialize();
      } catch (error) {
        if (process.env.NODE_ENV === "development") {
          console.error("Failed to initialize E2EE:", error);
        }
      }
    }
    this.addSettingTab(new LineSettingTab(this.app, this));
    this.addCommand({
      id: "sync-line-messages",
      name: "Sync LINE messages",
      callback: async () => {
        await this.syncMessages();
      }
    });
    this.addRibbonIcon("refresh-cw", "Sync LINE messages", async () => {
      await this.syncMessages();
    });
    this.setupAutoSync();
    if (this.settings.syncOnStartup) {
      setTimeout(() => {
        this.syncMessages(true);
      }, 3e3);
    }
  }
  onunload() {
    this.clearAutoSync();
  }
  async loadSettings() {
    const data = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  async saveSettings() {
    const currentData = await this.loadData() || {};
    const dataToSave = {
      ...currentData,
      ...this.settings
    };
    await this.saveData(dataToSave);
    this.setupAutoSync();
  }
  toJST(timestamp) {
    return new Date(timestamp);
  }
  getJSTDateString(timestamp) {
    const jstDate = this.toJST(timestamp);
    return jstDate.toISOString().split("T")[0].replace(/-/g, "");
  }
  getJSTDateWithHyphens(timestamp) {
    const jstDate = this.toJST(timestamp);
    return jstDate.toISOString().split("T")[0];
  }
  getJSTISOString(timestamp) {
    const jstDate = this.toJST(timestamp);
    return jstDate.toISOString();
  }
  getJSTTimeForFileName(timestamp) {
    const jstDate = this.toJST(timestamp);
    const year = jstDate.getFullYear();
    const month = String(jstDate.getMonth() + 1).padStart(2, "0");
    const day = String(jstDate.getDate()).padStart(2, "0");
    const hour = String(jstDate.getHours()).padStart(2, "0");
    const minute = String(jstDate.getMinutes()).padStart(2, "0");
    const second = String(jstDate.getSeconds()).padStart(2, "0");
    return `${year}${month}${day}${hour}${minute}${second}`;
  }
  getTimeOnly(timestamp) {
    const jstDate = this.toJST(timestamp);
    const hour = String(jstDate.getHours()).padStart(2, "0");
    const minute = String(jstDate.getMinutes()).padStart(2, "0");
    const second = String(jstDate.getSeconds()).padStart(2, "0");
    return `${hour}${minute}${second}`;
  }
  getJSTTimeString(timestamp) {
    const jstDate = this.toJST(timestamp);
    const hour = String(jstDate.getHours()).padStart(2, "0");
    const minute = String(jstDate.getMinutes()).padStart(2, "0");
    const second = String(jstDate.getSeconds()).padStart(2, "0");
    return `${hour}:${minute}:${second}`;
  }
  generateFileName(message) {
    const template = this.settings.fileNameTemplate;
    const timestamp = message.timestamp;
    const variables = {
      "{date}": this.getJSTDateWithHyphens(timestamp),
      "{datecompact}": this.getJSTDateString(timestamp),
      "{time}": this.getTimeOnly(timestamp),
      "{datetime}": this.getJSTTimeForFileName(timestamp),
      "{messageId}": message.messageId,
      "{userId}": message.userId,
      "{timestamp}": timestamp.toString()
    };
    let fileName = template;
    for (const [variable, value] of Object.entries(variables)) {
      fileName = fileName.replace(new RegExp(variable.replace(/[{}]/g, "\\$&"), "g"), value);
    }
    if (!fileName.endsWith(".md")) {
      fileName += ".md";
    }
    return fileName;
  }
  async generateUniqueFileName(message, folderPath) {
    const baseFileName = this.generateFileName(message);
    const baseName = baseFileName.replace(/\.md$/, "");
    const extension = ".md";
    let uniqueFileName = baseFileName;
    let counter = 1;
    while (true) {
      const fullPath = (0, import_obsidian2.normalizePath)(`${folderPath}/${uniqueFileName}`);
      const file = this.app.vault.getAbstractFileByPath(fullPath);
      const exists = file !== null;
      if (!exists) {
        return uniqueFileName;
      }
      uniqueFileName = `${baseName}_${counter}${extension}`;
      counter++;
    }
  }
  setupAutoSync() {
    this.clearAutoSync();
    if (this.settings.autoSync) {
      const interval = Math.max(1, Math.min(5, this.settings.syncInterval));
      const intervalMs = interval * 60 * 60 * 1e3;
      this.syncIntervalId = window.setInterval(() => {
        this.syncMessages(true);
      }, intervalMs);
    }
  }
  clearAutoSync() {
    if (this.syncIntervalId !== null) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  parseMessageTemplate(template, message, messageText) {
    return parseMessageTemplate(template, message, messageText, (timestamp) => this.getJSTTimeString(timestamp));
  }
  async syncMessages(isAutoSync = false) {
    if (!this.settings.vaultId) {
      new import_obsidian2.Notice("Vault ID not configured. Please set it in plugin settings.");
      return;
    }
    const keys = await this.keyManager.loadKeys();
    if (!keys && this.settings.lineUserId) {
      try {
        await this.keyManager.initialize();
      } catch (error) {
        if (process.env.NODE_ENV === "development") {
          console.error("Failed to initialize E2EE during sync:", error);
        }
      }
    }
    try {
      if (!isAutoSync) {
        new import_obsidian2.Notice("Syncing LINE messages...");
      }
      const url = API_ENDPOINTS.MESSAGES(this.settings.vaultId, this.settings.lineUserId);
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        method: "GET"
      });
      if (response.status !== 200) {
        throw new Error(`Failed to fetch messages: ${response.status}`);
      }
      const responseText = response.text;
      let messages;
      try {
        messages = JSON.parse(responseText);
      } catch (parseError) {
        throw new Error("Invalid response format");
      }
      let newMessageCount = 0;
      const syncedMessageIds = [];
      if (this.settings.groupMessagesByDate) {
        const messagesByDate = /* @__PURE__ */ new Map();
        for (const message of messages) {
          if (message.synced) {
            continue;
          }
          const dateString = this.getJSTDateString(message.timestamp);
          if (!messagesByDate.has(dateString)) {
            messagesByDate.set(dateString, []);
          }
          messagesByDate.get(dateString).push(message);
        }
        for (const [dateString, dateMessages] of messagesByDate) {
          let folderPath;
          if (this.settings.organizeByDate) {
            folderPath = `${this.settings.noteFolderPath}/${dateString}`;
          } else {
            folderPath = this.settings.noteFolderPath;
          }
          try {
            const normalizedFolderPath = (0, import_obsidian2.normalizePath)(this.settings.noteFolderPath);
            const folder = this.app.vault.getAbstractFileByPath(normalizedFolderPath);
            if (!folder) {
              await this.app.vault.createFolder(normalizedFolderPath);
            }
            const normalizedTargetFolderPath = (0, import_obsidian2.normalizePath)(folderPath);
            const targetFolder = this.app.vault.getAbstractFileByPath(normalizedTargetFolderPath);
            if (!targetFolder) {
              await this.app.vault.createFolder(normalizedTargetFolderPath);
            }
            const fileNameWithoutExt = parseFrontmatterTemplate(this.settings.groupedFileNameTemplate, dateString);
            const fileName = `${fileNameWithoutExt}.md`;
            const filePath = `${folderPath}/${fileName}`;
            const normalizedFilePath = (0, import_obsidian2.normalizePath)(filePath);
            let existingContent = "";
            const existingFile = this.app.vault.getAbstractFileByPath(normalizedFilePath);
            if (existingFile instanceof import_obsidian2.TFile) {
              existingContent = await this.app.vault.read(existingFile);
            }
            const newMessages = [];
            for (const message of dateMessages) {
              let messageText;
              try {
                messageText = await this.messageEncryptor.processMessage(message);
              } catch (error) {
                try {
                  messageText = await this.errorHandler.handleError(error, `message_${message.messageId}`);
                } catch (handlerError) {
                  if (process.env.NODE_ENV === "development") {
                    console.error(`Failed to process message ${message.messageId}:`, handlerError);
                  }
                  messageText = message.text || "[\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F]";
                }
              }
              const messageContent = this.parseMessageTemplate(
                this.settings.groupedMessageTemplate,
                message,
                messageText
              );
              newMessages.push(messageContent);
              syncedMessageIds.push(message.messageId);
              newMessageCount++;
            }
            let finalContent;
            if (existingContent) {
              finalContent = existingContent.trimEnd() + "\n" + newMessages.join("\n");
            } else {
              const parsedFrontmatter = parseFrontmatterTemplate(this.settings.groupedFrontmatterTemplate, dateString);
              const frontmatter = [
                `---`,
                parsedFrontmatter,
                `---`,
                ``,
                ""
              ].join("\n");
              finalContent = frontmatter + newMessages.join("\n");
            }
            const fileToWrite = this.app.vault.getAbstractFileByPath(normalizedFilePath);
            if (fileToWrite instanceof import_obsidian2.TFile) {
              await this.app.vault.modify(fileToWrite, finalContent);
            } else {
              await this.app.vault.create(normalizedFilePath, finalContent);
            }
          } catch (err) {
            if (process.env.NODE_ENV === "development") {
              console.error(`Error processing messages for date ${dateString}: ${err}`);
            }
          }
        }
      } else {
        for (const message of messages) {
          if (message.synced) {
            continue;
          }
          let folderPath;
          if (this.settings.organizeByDate) {
            const dateString = this.getJSTDateString(message.timestamp);
            folderPath = `${this.settings.noteFolderPath}/${dateString}`;
          } else {
            folderPath = this.settings.noteFolderPath;
          }
          try {
            const fileName = await this.generateUniqueFileName(message, folderPath);
            const filePath = `${folderPath}/${fileName}`;
            const normalizedFilePath = (0, import_obsidian2.normalizePath)(filePath);
            const normalizedFolderPath = (0, import_obsidian2.normalizePath)(this.settings.noteFolderPath);
            const baseFolder = this.app.vault.getAbstractFileByPath(normalizedFolderPath);
            if (!baseFolder) {
              await this.app.vault.createFolder(normalizedFolderPath);
            }
            const normalizedTargetFolderPath = (0, import_obsidian2.normalizePath)(folderPath);
            const targetFolder = this.app.vault.getAbstractFileByPath(normalizedTargetFolderPath);
            if (!targetFolder) {
              await this.app.vault.createFolder(normalizedTargetFolderPath);
            }
            let messageText;
            try {
              messageText = await this.messageEncryptor.processMessage(message);
            } catch (error) {
              try {
                messageText = await this.errorHandler.handleError(error, `message_${message.messageId}`);
              } catch (handlerError) {
                if (process.env.NODE_ENV === "development") {
                  console.error(`Failed to process message ${message.messageId}:`, handlerError);
                }
                messageText = message.text || "[\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F]";
              }
            }
            const content = [
              `---`,
              `source: LINE`,
              `date: ${this.getJSTISOString(message.timestamp)}`,
              `messageId: ${message.messageId}`,
              `userId: ${message.userId}`,
              `---`,
              ``,
              `${messageText}`
            ].join("\n");
            await this.app.vault.create(normalizedFilePath, content);
            newMessageCount++;
            syncedMessageIds.push(message.messageId);
          } catch (err) {
            if (process.env.NODE_ENV === "development") {
              console.error(`Error processing message ${message.messageId}: ${err}`);
            }
          }
        }
      }
      if (syncedMessageIds.length > 0) {
        await this.updateSyncStatus(syncedMessageIds);
      }
      if (newMessageCount > 0 || !isAutoSync) {
        new import_obsidian2.Notice(`LINE messages synced successfully. ${newMessageCount} new messages.`);
      }
    } catch (err) {
      new import_obsidian2.Notice(`Failed to sync LINE messages: ${err instanceof Error ? err.message : "Unknown error"}`);
    }
  }
  async updateSyncStatus(messageIds) {
    try {
      if (!this.settings.lineUserId) {
        if (process.env.NODE_ENV === "development") {
          console.error("LINE User ID not configured. Cannot update sync status.");
        }
        return;
      }
      const response = await (0, import_obsidian3.requestUrl)({
        url: API_ENDPOINTS.UPDATE_SYNC_STATUS,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          vaultId: this.settings.vaultId,
          messageIds,
          userId: this.settings.lineUserId
        })
      });
      if (response.status !== 200) {
        if (process.env.NODE_ENV === "development") {
          console.error(`Failed to update sync status: ${response.status}`);
        }
      }
    } catch (err) {
      if (process.env.NODE_ENV === "development") {
        console.error(`Error updating sync status: ${err instanceof Error ? err.message : "Unknown error"}`);
      }
    }
  }
  async registerMapping() {
    if (!this.settings.lineUserId || !this.settings.vaultId) {
      new import_obsidian2.Notice("LINE UserID\u3068Vault ID\u306E\u4E21\u65B9\u3092\u8A2D\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044\u3002");
      return;
    }
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url: API_ENDPOINTS.MAPPING,
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          userId: this.settings.lineUserId,
          vaultId: this.settings.vaultId
        })
      });
      if (response.status !== 200) {
        throw new Error("\u30DE\u30C3\u30D4\u30F3\u30B0\u306E\u767B\u9332\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      }
      try {
        await this.keyManager.initialize();
      } catch (keyError) {
        if (process.env.NODE_ENV === "development") {
          console.error("Failed to initialize keys after mapping:", keyError);
        }
      }
      new import_obsidian2.Notice("LINE UserID\u3068Vault ID\u306E\u30DE\u30C3\u30D4\u30F3\u30B0\u3092\u767B\u9332\u3057\u307E\u3057\u305F\u3002");
    } catch (error) {
      new import_obsidian2.Notice(`\u30DE\u30C3\u30D4\u30F3\u30B0\u306E\u767B\u9332\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
};
var LineSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Note folder path").setDesc("LINE\u30E1\u30C3\u30BB\u30FC\u30B8\u304C\u4FDD\u5B58\u3055\u308C\u308B\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9").addText((text) => text.setPlaceholder("LINE").setValue(this.plugin.settings.noteFolderPath).onChange(async (value) => {
      this.plugin.settings.noteFolderPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Vault ID").setDesc("\u3053\u306EObsidian Vault\u7528\u306E\u4E00\u610F\u306E\u8B58\u5225\u5B50\uFF08\u4EFB\u610F\u306E\u30E6\u30CB\u30FC\u30AF\u306AID\u3092\u4F5C\u6210\u3057\u3066\u304F\u3060\u3055\u3044\uFF09").addText((text) => text.setPlaceholder("Enter vault ID").setValue(this.plugin.settings.vaultId).onChange(async (value) => {
      this.plugin.settings.vaultId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("LINE user ID").setDesc("LINE\u30DC\u30C3\u30C8\u3068\u306E\u4F1A\u8A71\u3067\u53D6\u5F97\u3057\u305F\u30E6\u30FC\u30B6\u30FCID\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044").addText((text) => text.setPlaceholder("Enter your LINE User ID").setValue(this.plugin.settings.lineUserId).onChange(async (value) => {
      this.plugin.settings.lineUserId = value;
      await this.plugin.saveSettings();
    }));
    const autoSyncSetting = new import_obsidian2.Setting(containerEl).setName("Auto sync").setDesc("LINE\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u81EA\u52D5\u7684\u306B\u540C\u671F\u3059\u308B\u304B\u3069\u3046\u304B").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      syncIntervalSetting.settingEl.toggle(value);
    }));
    const syncIntervalSetting = new import_obsidian2.Setting(containerEl).setName("Sync interval").setDesc("LINE\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u540C\u671F\u3059\u308B\u9593\u9694\uFF08\u6642\u9593\u5358\u4F4D\uFF09").addDropdown((dropdown) => {
      const hours = [1, 2, 3, 4, 5];
      hours.forEach((hour) => {
        dropdown.addOption(hour.toString(), `${hour}\u6642\u9593`);
      });
      dropdown.setValue(this.plugin.settings.syncInterval.toString());
      dropdown.onChange(async (value) => {
        const interval = parseInt(value);
        if (!isNaN(interval) && interval >= 1 && interval <= 5) {
          this.plugin.settings.syncInterval = interval;
          await this.plugin.saveSettings();
        }
      });
    });
    syncIntervalSetting.settingEl.toggle(this.plugin.settings.autoSync);
    new import_obsidian2.Setting(containerEl).setName("Sync on startup").setDesc("Obsidian\u8D77\u52D5\u6642\u306BLINE\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u540C\u671F\u3059\u308B\u304B\u3069\u3046\u304B").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnStartup).onChange(async (value) => {
      this.plugin.settings.syncOnStartup = value;
      await this.plugin.saveSettings();
    }));
    let organizeBydateToggle;
    const organizeBydateSetting = new import_obsidian2.Setting(containerEl).setName("Organize by date").setDesc("\u65E5\u4ED8\u3054\u3068\u306B\u30D5\u30A9\u30EB\u30C0\u3092\u4F5C\u6210\u3057\u3066\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u6574\u7406\u3059\u308B\u304B\u3069\u3046\u304B\uFF08\u6CE8\u610F\uFF1A\u300CGroup messages by date\u300D\u3092\u30AA\u30F3\u306B\u3059\u308B\u3068\u81EA\u52D5\u7684\u306B\u30AA\u30D5\u306B\u306A\u308A\u307E\u3059\u304C\u3001\u624B\u52D5\u3067\u518D\u5EA6\u30AA\u30F3\u306B\u3059\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059\uFF09").addToggle((toggle) => {
      organizeBydateToggle = toggle;
      toggle.setValue(this.plugin.settings.organizeByDate).onChange(async (value) => {
        this.plugin.settings.organizeByDate = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setHeading().setName("\u30D5\u30A1\u30A4\u30EB\u6574\u7406\u8A2D\u5B9A");
    new import_obsidian2.Setting(containerEl).setName("Group messages by date").setDesc("\u540C\u3058\u65E5\u4ED8\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u30921\u3064\u306E\u30D5\u30A1\u30A4\u30EB\u306B\u307E\u3068\u3081\u308B\u304B\u3069\u3046\u304B\uFF08\u30C1\u30A7\u30C3\u30AF\u3092\u5916\u3059\u3068\u30E1\u30C3\u30BB\u30FC\u30B8\u3054\u3068\u306B\u500B\u5225\u306E\u30D5\u30A1\u30A4\u30EB\u3092\u4F5C\u6210\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.groupMessagesByDate).onChange(async (value) => {
      this.plugin.settings.groupMessagesByDate = value;
      if (value && this.plugin.settings.organizeByDate) {
        this.plugin.settings.organizeByDate = false;
        if (organizeBydateToggle) {
          organizeBydateToggle.setValue(false);
        }
      }
      await this.plugin.saveSettings();
      messageTemplateSetting.settingEl.toggle(value);
      frontmatterTemplateSetting.settingEl.toggle(value);
      groupedFileNameSetting.settingEl.toggle(value);
    }));
    const messageTemplateSetting = new import_obsidian2.Setting(containerEl).setName("Grouped message template").setDesc("\u65E5\u4ED8\u3067\u30B0\u30EB\u30FC\u30D7\u5316\u3055\u308C\u305F\u30E1\u30C3\u30BB\u30FC\u30B8\u306E\u8868\u793A\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\n\u5229\u7528\u53EF\u80FD\u306A\u5909\u6570: {time} - \u6642\u523B, {text} - \u30E1\u30C3\u30BB\u30FC\u30B8\u5185\u5BB9, {messageId} - \u30E1\u30C3\u30BB\u30FC\u30B8ID, {userId} - \u30E6\u30FC\u30B6\u30FCID").addTextArea((text) => {
      text.setPlaceholder("{time}: {text}").setValue(this.plugin.settings.groupedMessageTemplate).onChange(async (value) => {
        this.plugin.settings.groupedMessageTemplate = value || "{time}: {text}";
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 3;
      return text;
    });
    messageTemplateSetting.settingEl.toggle(this.plugin.settings.groupMessagesByDate);
    const frontmatterTemplateSetting = new import_obsidian2.Setting(containerEl).setName("Grouped message frontmatter template").setDesc("\u65E5\u4ED8\u3067\u30B0\u30EB\u30FC\u30D7\u5316\u3055\u308C\u305F\u30D5\u30A1\u30A4\u30EB\u306E\u30D5\u30ED\u30F3\u30C8\u30DE\u30BF\u30FC\n\u5229\u7528\u53EF\u80FD\u306A\u5909\u6570: {date} - \u65E5\u4ED8, {datecompact} - \u65E5\u4ED8\uFF08\u30CF\u30A4\u30D5\u30F3\u306A\u3057\uFF09").addTextArea((text) => {
      text.setPlaceholder("source: LINE\ndate: {date}").setValue(this.plugin.settings.groupedFrontmatterTemplate).onChange(async (value) => {
        this.plugin.settings.groupedFrontmatterTemplate = value || "source: LINE\ndate: {date}";
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 5;
      return text;
    });
    frontmatterTemplateSetting.settingEl.toggle(this.plugin.settings.groupMessagesByDate);
    const groupedFileNameSetting = new import_obsidian2.Setting(containerEl).setName("Grouped file name template").setDesc("\u65E5\u4ED8\u3054\u3068\u306B\u307E\u3068\u3081\u3089\u308C\u305F\u30D5\u30A1\u30A4\u30EB\u306E\u540D\u524D\uFF08\u300CGroup messages by date\u300D\u304C\u30AA\u30F3\u306E\u5834\u5408\u306B\u4F7F\u7528\uFF09\n\u5229\u7528\u53EF\u80FD\u306A\u5909\u6570: {date} - \u65E5\u4ED8 (\u4F8B: 2024-01-15), {datecompact} - \u65E5\u4ED8\u30CF\u30A4\u30D5\u30F3\u306A\u3057 (\u4F8B: 20240115)").addText((text) => text.setPlaceholder("{date}").setValue(this.plugin.settings.groupedFileNameTemplate).onChange(async (value) => {
      this.plugin.settings.groupedFileNameTemplate = value || "{date}";
      await this.plugin.saveSettings();
    }));
    groupedFileNameSetting.settingEl.toggle(this.plugin.settings.groupMessagesByDate);
    const infoBox = containerEl.createDiv({ cls: "setting-item-description" });
    infoBox.style.backgroundColor = "var(--background-secondary)";
    infoBox.style.padding = "10px";
    infoBox.style.borderRadius = "5px";
    infoBox.style.marginBottom = "20px";
    infoBox.createEl("strong", { text: "\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u4F7F\u3044\u5206\u3051\uFF1A" });
    infoBox.createEl("br");
    infoBox.createEl("span", { text: "\u2022 " });
    infoBox.createEl("strong", { text: "Group messages by date \u304C\u30AA\u30F3\uFF1A" });
    infoBox.createEl("span", { text: " 1\u65E5\u5206\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u304C1\u3064\u306E\u30D5\u30A1\u30A4\u30EB\u306B\u307E\u3068\u3081\u3089\u308C\u3001\u300CGrouped file name template\u300D\u304C\u4F7F\u7528\u3055\u308C\u307E\u3059" });
    infoBox.createEl("br");
    infoBox.createEl("span", { text: "  \u203B \u56FA\u5B9A\u306E\u30D5\u30A1\u30A4\u30EB\u540D\uFF08\u4F8B\uFF1A{date}\u3092\u4F7F\u308F\u305A\u306B\u300CLINE-Messages\u300D\u306A\u3069\uFF09\u3092\u8A2D\u5B9A\u3059\u308B\u3068\u3001\u3059\u3079\u3066\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u304C\u5E38\u306B\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u306B\u8FFD\u8A18\u3055\u308C\u307E\u3059" });
    infoBox.createEl("br");
    infoBox.createEl("span", { text: "\u2022 " });
    infoBox.createEl("strong", { text: "Group messages by date \u304C\u30AA\u30D5\uFF1A" });
    infoBox.createEl("span", { text: " \u5404\u30E1\u30C3\u30BB\u30FC\u30B8\u304C\u500B\u5225\u306E\u30D5\u30A1\u30A4\u30EB\u3068\u3057\u3066\u4FDD\u5B58\u3055\u308C\u3001\u300CIndividual message file name template\u300D\u304C\u4F7F\u7528\u3055\u308C\u307E\u3059" });
    new import_obsidian2.Setting(containerEl).setName("Individual message file name template").setDesc("\u500B\u5225\u30E1\u30C3\u30BB\u30FC\u30B8\u30D5\u30A1\u30A4\u30EB\u306E\u30D5\u30A1\u30A4\u30EB\u540D\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\uFF08\u300CGroup messages by date\u300D\u304C\u30AA\u30D5\u306E\u5834\u5408\u306B\u4F7F\u7528\uFF09\n\u5229\u7528\u53EF\u80FD\u306A\u5909\u6570: {date}, {datecompact}, {time}, {datetime}, {messageId}, {userId}, {timestamp}").addText((text) => text.setPlaceholder("{date}-{messageId}").setValue(this.plugin.settings.fileNameTemplate).onChange(async (value) => {
      this.plugin.settings.fileNameTemplate = value || "{date}-{messageId}";
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("div", {
      text: "\u5909\u6570\u306E\u8AAC\u660E:",
      cls: "setting-item-description"
    });
    containerEl.createEl("ul", {}, (ul) => {
      ul.createEl("li", { text: "{date}: \u65E5\u4ED8 (\u4F8B: 2024-01-15)" });
      ul.createEl("li", { text: "{datecompact}: \u65E5\u4ED8\uFF08\u30CF\u30A4\u30D5\u30F3\u306A\u3057\uFF09 (\u4F8B: 20240115)" });
      ul.createEl("li", { text: "{time}: \u6642\u523B (\u4F8B: 103045)" });
      ul.createEl("li", { text: "{datetime}: \u65E5\u6642 (\u4F8B: 20240115103045)" });
      ul.createEl("li", { text: "{messageId}: \u30E1\u30C3\u30BB\u30FC\u30B8ID" });
      ul.createEl("li", { text: "{userId}: \u30E6\u30FC\u30B6\u30FCID" });
      ul.createEl("li", { text: "{timestamp}: Unix\u30BF\u30A4\u30E0\u30B9\u30BF\u30F3\u30D7" });
    });
    new import_obsidian2.Setting(containerEl).setName("Register mapping").setDesc("LINE UserID\u3068Vault ID\u306E\u30DE\u30C3\u30D4\u30F3\u30B0\u3092\u767B\u9332\u3057\u307E\u3059").addButton((button) => button.setButtonText("Register").onClick(async () => {
      await this.plugin.registerMapping();
    }));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});

/* nosourcemap */