
> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=277,0,282,63&color=yellow|Integer-Programming, p.18]]
> > An algorithm for solving a problem is a procedure that, given any possible instance, produces the correct answer in a finite amount of time
> 
> 問題に対するアルゴリズムとは、有限時間内に正しいアンサーを見つける手順である。だが、ここは試行回数が無限になるニュートン法なので議論があるらしいので、調べる必要がある。

> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=282,64,284,38&color=yellow|Integer-Programming, p.18]]
> >  For example, Dantzig’s simplex method with an anti-cycling rule is an algorithm for solving the linear programming problem
> 
> ダンツィクのアルゴリズムは線形計画問題を解くシンプレックス法=単体法らしい。単体法で循環しないための、最小添字規則のような反サイクル規則を備えて要るっぽい。このあたりの紹介も軽くしておくと勉強になるかも。
> 
> https://orsj.org/wp-content/corsj/or64-4/or64_4_209.pdf

> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=285,1,287,21&color=yellow|Integer-Programming, p.18]]
> > Karmarkar’s interior point algorithm is another.
> 
> カーマーカーの内点法も別のアルゴリズム。これも紹介するか？と思ったが、PDFで14枚分のボリュームであるので割愛しよう。。。
> 
> https://www.nakatalab.iee.e.titech.ac.jp/text/pdf/IP/IP2B-Karmarkar.pdf

> [!PDF|red] [[Integer-Programming.pdf#page=31&selection=287,22,309,2&color=red|Integer-Programming, p.18]]
> > An algorithm is said to solve a problem in polynomial time if its running time, measured as the number of arithmetic operations carried out by the algorithm (a function f defined on the set S of instances), is polynomially bounded by the encoding size of the input (a function g defined on S).
> 
> **「アルゴリズムが多項式時間で問題を解く」についての定義がされている。**アルゴリズムの実行時間が入力のエンコーディングサイズによって多項式で抑えられる場合にそう呼ばれる。「多項式時間アルゴリズム」の代わりに「多項式アルゴリズム」と呼ぶらしい。

> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=314,2,319,1&color=yellow|Integer-Programming, p.18]]
> > Karmarkar’s interior point algorithm is a polynomial algorithm for linear programming but the simplex method is not (Klee and Minty [240] gave a family of instances where the simplex method with the largest cost pivoting rule (Dantzig’s rule) takes an exponential number of steps as a function of the instance size). 
> 
> カーマーカーの内点法アルゴリズムは線形計画法のための多項式アルゴリズム。一方、単体法は厳密にはそうではない。クレーとミンティがdantzigルールを用いた単体法がインスタンスサイズを関数として、指数関数的なステップ数を要するインスタンスの例を示したから。
> https://www.titech.ac.jp/news/2017/037824
> 引用を後で読んでみるか。

> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=320,0,325,1&color=yellow|Integer-Programming, p.18]]
> > A problem is said to be in the complexity class P if there exists a polynomial algorithm to solve it. 
> 
> 多項式アルゴリズムが存在するならば、その問題は複雑性クラスPに属すると一般的に言われている。

> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=326,0,329,0&color=yellow|Integer-Programming, p.18]]
> > For example linear programming is in P since Karmarkar’s algorithm solves it in polynomial time.
> 
> 線形計画法は、カーマーカ―のアルゴリズムを用いて多項式時間で解くことが出来るため、Pに属する。

> [!PDF|yellow] [[Integer-Programming.pdf#page=31&selection=330,0,361,19&color=yellow|Integer-Programming, p.18]]
> > Specifically, if L denotes the encoding size of a linear program with n variables, Karmarkar’s algorithm performs O(n3.5L) arithmetic operations, where the sizes of numbers during the entire execution is O(L). The running time was later improved to O(n3L) by Renegar [314].
> 
> 具体的には、n変数を持つ線形計画法のエンコーディングサイズをLとして、カーマーカ―のアルゴリズムはO(n^3.5L)の算術演算を実行し、全実行中の数値のサイズはO(L)となる。後にレネガーによって実行時間はO(n^3L)に改善された。
> 引用が書いてあるので読んだ方が良いかも。

> [!PDF|yellow] [[Integer-Programming.pdf#page=32&selection=5,0,20,1&color=yellow|Integer-Programming, p.19]]
> > Another issue in computational complexity is the encoding size of the output as a function of the encoding size of the input. For example, given some input A, b, what is the encoding size of a solution to Ax = b?
> 
> 計算複雑性のもう一つの問題は、**出力のエンコーディングサイズが入力のエンコーディングサイズの関数としてどのようになるか** である。

> [!PDF|red] [[Integer-Programming.pdf#page=32&selection=22,0,60,1&color=red|Integer-Programming, p.19]]
> > Proposition 1.2. Let A be a nonsingular n × n rational matrix and b a rational n-vector. The encoding size of the unique solution of Ax = b is polynomially bounded by the encoding size of (A, b).
> 
> **Aをn×nの正則な有理行列とし、bを有理数のn次元ベクトルとすれば、Ax=bの解のエンコーディングサイズは、(A, b)のエンコーディングサイズによって多項式に抑えられる** という命題。

> [!PDF|yellow] [[Integer-Programming.pdf#page=32&selection=61,0,153,1&color=yellow|Integer-Programming, p.19]]
> > Proof. By Remark 1.1, we may assume that (A, b) has integer entries. Let θ be the largest absolute value of an entry in (A, b). The absolute value of the determinant of any square n×n submatrix of (A, b) is at most n!θn (by using the standard formula for computing determinants as the sum of n! products of n entries). The encoding size of n!θn is O(n(log n + log(1 + θ))), thus it is polynomially bounded by n and the encoding size of θ. By Cramer’s rule, each entry of A−1b is the ratio of two such determinants. Now the proposition follows by observing that the encoding size of (A, b) is at least n + log2(1 + θ) .
> 
> 上の命題の証明が書かれている。これは後で追おうか

> [!PDF|yellow] [[Integer-Programming.pdf#page=32&selection=159,0,163,50&color=yellow|Integer-Programming, p.19]]
> > A decision problem is a problem whose answer is either “yes” or “no.”
> 
> 決定問題とは、「はい」または「いいえ」のどちらかで答えられる問題のこと。
> 

> [!PDF|red] [[Integer-Programming.pdf#page=32&selection=164,0,175,40&color=red|Integer-Programming, p.19]]
> > An important complexity class is NP, which stands for “nondeterministic polynomial-time.” Intuitively, NP is the class of all decision problems for which the “yes”-answer has a certificate that can be checked in polynomial time. The complexity class Co-NP is the class of all decision problems for which the “no”-answer has a certificate that can be checked in polynomial time, see Exercises 1.10, 1.11 and 1.12.
> 
> NPとCo-NPに対する定義が書かれているが、なんのこっちゃだから後で深堀りしよう。
> 直感的には、**NP** とは、「はい」という答えに対して、多項式時間で検証可能な証明書が存在する決定問題のクラスです 。複雑性クラス **Co-NP** は、「いいえ」という答えに対して、多項式時間で検証可能な証明書が存在する決定問題のクラスです （演習 1.10、1.11、1.12 を参照）。

> [!PDF|yellow] [[Integer-Programming.pdf#page=32&selection=214,73,216,25&color=yellow|Integer-Programming, p.19]]
> > We will show in Chap. 4 that the question “given a mixed integer linear set, is it nonempty?” is in NP. 
> 
> 第4章において、「与えられた混合整数線形集合が空でないか」という問題がNPに属することを示すらしい。

> [!PDF|yellow] [[Integer-Programming.pdf#page=32&selection=229,0,232,43&color=yellow|Integer-Programming, p.19]]
> > On the other hand, the question “given a mixed integer linear set, is it empty?” does not have any obvious certificate that can be checked in polynomial time and, in fact, it is conjectured that this problem is not in NP.
> 
> 逆の問題においては、NPに属する多項式時間で検証可能な証明が存在せず、NPに属さないと予想されている。

> [!PDF|red] [[Integer-Programming.pdf#page=33&selection=6,0,28,1&color=red|Integer-Programming, p.20]]
> > A decision problem Q in NP is said to be NP-complete if all other problems D in NP are reducible to Q in polynomial time. 
> 
> NP完全問題とは、以下の条件を満たす問題である。
> ①NPに属する決定問題
> ②他のすべてのNPに属する問題Dが多項式時間でQに帰着(還元)できる

> [!PDF|yellow] [[Integer-Programming.pdf#page=33&selection=28,1,52,49&color=yellow|Integer-Programming, p.20]]
> > That is there exists a polynomial algorithm that, for every instance I of D, produces an instance of Q whose answer is “yes” if and only if the answer to I is yes. This implies that, up to a polynomial factor, solving Q requires at least as much computing time as solving any problem in NP.
> 
> このあたりは自分のノート確認した方が分かりやすい。

> [!PDF|red] [[Integer-Programming.pdf#page=33&selection=54,27,72,19&color=red|Integer-Programming, p.20]]
> > Analogously, a decision problem Q in co-NP is said to be co-NP-complete if all other problems D in co-NP are reducible to Q in polynomial time.
> 
> co-NPについても同様にco-NP完全が定義される

> [!PDF|red] [[Integer-Programming.pdf#page=33&selection=73,0,121,23&color=red|Integer-Programming, p.20]]
> > A problem Q (not necessarily in NP or a decision problem) is said to be NP-hard if all problems D in NP are reducible to Q in polynomial time. That is, there exist two polynomial algorithms such that the first produces an instance J(I) of Q for any given instance I of D, and the second produces the correct answer for I given a solution for J(I). In particular, integer programming is NP-hard.
> 
> NP困難の説明



来週 ... 1.3.2節から

### 用語
- non-singular n×n rational matrix：n×nの正則な有理行列
- analogously：同様に