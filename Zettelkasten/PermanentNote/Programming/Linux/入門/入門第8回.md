---
title: Linux講座第8回
AI:
published: 2025-09-03
description:
tags:
  - permanent-note
  - linux
---
**Linux講座**
- https://engineer-ninaritai.com/infraacademy/course-category/linux/?loop_content_only=false&column_per_row=3&course_per_page=12&show_pagination=false&keyword=Linux%E5%85%A5%E9%96%80&tutor-course-filter-category=57&course_order=oldest_first&course_filter=true&loop_content_only=false&column_per_row=3&course_per_page=12&show_pagination=false&current_page=1&action=tutor_course_filter_ajax

---
##### 正規表現とは？

正規表現とは、**文字列のパターンを記述するための表現方法**です。

これだけだと、正規表現が何なのかよくわからないので、具体例を説明します。

###### 正規表現を使う具体例

正規表現を使う具体例を紹介します。

例えば、名前と住所、電話番号が載ったテキストデータがあったとします。

ここから、**電話番号だけ抜き出すにはどうしたら良いのでしょうか？**
![[Pasted image 20250903190217.png]]

ここで使われるのが正規表現です。

電話番号には、特定のパターンが存在します。

**電話番号の特定のパターンとは何なのでしょうか？**

それは、**“3桁の数字” – “4桁の数字” – “4桁の数字”**となっています。

この特定のパターンに沿ったものだけを抜き出すことで、電話番号だけを抜き出すことができるのです。

正規表現は、**“3桁の数字” – “4桁の数字” – “4桁の数字”のような文字列のパターンを表現した文字のことを指します。**

電話番号(“3桁の数字” – “４桁の数字” – “4桁の数字”)を正規表現で表すと、以下のような記号になります。

^\d{3}-\d{4}-\d{4}$

※↑こちらの正規表現の意味については、後ほど解説します。]

この正規表現を使うことで、電話番号を抜き出すことができます。
![[Pasted image 20250903192000.png]]

正規表現を理解することで、何か特定のパターンの文字列を検索したり、編集したりすることができます。

次に正規表現を実際に使って試してみましょう。

---
##### 正規表現を使って特定の文字パターンを表示してみよう

###### 正規表現を実践してみる

今回は、**テキストファイルの中から数字だけ抜き出すことをやってみます。**

まずは、テキストファイルを準備します。viコマンドを使って、sample.txtファイルを編集します。

```bash
vi sample.txt
```

sample.txtファイルの中身を以下のように記述します。

```bash
test 1
sample
abc 2
```

ファイルの中身をcatコマンドで確認してみましょう。

```bash
cat sample.txt
```

正しくテキストデータが入力されていればOKです。
![[Pasted image 20250903192242.png]]

続いて、正規表現を使って数字だけ抜き出すためには、grepコマンドを使用します。

以下のように実行しましょう。

```bash
grep -o -E [0-9] sample.txt
```

コマンドを実行すると、以下のように**sample.txtファイルの数字だけ抜き出すことができます。**
![[Pasted image 20250903192259.png]]

こちらの図は今回の流れです。正規表現を使って、テキストデータの中の数字だけ取り出しています。
![[Pasted image 20250903192309.png]]

---
##### 正規表現の用途

###### 検索(マッチング)

正規表現を使用して、文字列が特定のパターンに一致するかどうかを検索できます。

例えば、テキスト内の電話番号やメールアドレスを見つけることができます。

###### 置換

正規表現を使用して、一致する部分を新しい文字列に置き換えることができます。

例えば、文書内の特定の単語を別の単語に置き換えることができます。

###### 分割

正規表現を使用して、文字列を特定のパターンで分割し、部分文字列の配列を得ることができます。

例えば、カンマで区切られたデータを個別の要素に分割することができます。

###### 検証（バリデーション）

正規表現を使用して、文字列が特定の形式（例：メールアドレスや電話番号の形式）に一致するかどうかを検証できます。

---
##### 正規表現の表記方法

###### 文字列

文字列をそのまま表現するためには、その文字列をそのまま記述します。

例えば、”apple”という文字列をマッチさせたい場合は、以下のように実行します。

```bash
grep -E apple file.txt
```

###### 任意の1文字(.)

ドットは任意の1文字とマッチします。

```bash
grep -E a.c file.txt
```

この例では、”abc” や “axc” にマッチしますが、”acd” にはマッチしません。  
aとcの間の文字は任意の文字列でマッチします。

###### 先頭、文末

先頭を表す **^と文末を表す**$**を使用します。

```bash
grep -E ^start file.txt
grep -E end$ file.txt
```

最初の例では、行が “start” で始まる場合にマッチし、2つ目の例では、行が “end” で終わる場合にマッチします。

###### 指定したいずれかの文字

ブラケット内[]に指定された文字のいずれか1文字にマッチします。

```bash
grep -E [abcd] file.txt
```

この例では、abcdのいずれかの文字列が含まれている行にマッチします。  
数字をマッチさせる際に使った、[0-9]は0~9のいずれかが含まれているものにマッチします。

###### エスケープ文字

正規表現の特殊文字をそのまま表現するためにはバックスラッシュ \ を使います。

```bash
grep -E 'a\.c' file.txt
```

この例では、a.cにマッチします。  
バックスラッシュを使うことで、.(ドット)が任意の文字列でなく、文字の.(ドット)として認識されます。

また、バックスラッシュを使う際は、文字列を’ ‘で囲みましょう。

###### 定義済み正規表現

定義済みの正規表現もあります。例えば、数字をマッチさせる場合、[0-9]だけでなく、\dを指定することもできます。

```bash
grep -E \d　file.txt
```

\d以外にも、\D(数字以外にマッチ) \s(任意の文字列にマッチ)などがあります。

###### 正規表現の一覧

そのほかにも、正規表にはさまざまな表現方法があります。一覧を載せておくので参考にしてください。

| 正規表現        | 説明                                 |
| ----------- | ---------------------------------- |
| `^`         | 行の先頭にマッチ                           |
| `$`         | 行の末尾にマッチ                           |
| `.`         | 任意の1文字にマッチ                         |
| `\d`        | 任意の数字にマッチ (0-9)                    |
| `\D`        | 任意の数字以外の文字にマッチ                     |
| `\w`        | 任意の単語文字にマッチ (英数字とアンダースコア)          |
| `\W`        | 単語文字以外の文字にマッチ                      |
| `\s`        | 任意の空白文字にマッチ                        |
| `\S`        | 空白文字以外の文字にマッチ                      |
| `[abc]`     | a、b、cのいずれか1文字にマッチ                  |
| `[a-z]`     | aからzのいずれか1文字にマッチ                   |
| `[A-Z]`     | AからZのいずれか1文字にマッチ                   |
| `*`         | 直前の要素が0回以上繰り返すことにマッチ               |
| `+`         | 直前の要素が1回以上繰り返すことにマッチ               |
| `?`         | 直前の要素が0回または1回出現することにマッチ            |
| `\b`        | 単語の境界にマッチ                          |
| `\B`        | 単語の境界以外にマッチ                        |
| `\A`        | 文字列の先頭にマッチ                         |
| `\Z`        | 文字列の末尾にマッチ                         |
| `\d+`       | 1つ以上の数字にマッチ                        |
| `\w+`       | 1つ以上の単語文字にマッチ (英数字とアンダースコア)        |
| `\s+`       | 1つ以上の空白文字にマッチ                      |
| `[\w\s]+`   | 単語文字または空白文字の1つ以上にマッチ               |
| `[^0-9]`    | 数字以外の任意の1文字にマッチ                    |
| `{n}`       | 直前の文字がn回繰り返されたものにマッチ               |
| `{n,}`      | 直前の文字がn回以上繰り返されたものにマッチ             |
| `{n,m}`     | 直前の文字がn~m回以上繰り返されたものにマッチ           |
| `(expr)`    | グループ化し、後続の量指定子を適用                  |
| `expr?`     | `expr` が0回または1回出現することにマッチ          |
| `expr{n}`   | `expr` がちょうど `n` 回出現することにマッチ       |
| `expr{n,}`  | `expr` が `n` 回以上出現することにマッチ         |
| `expr{n,m}` | `expr` が `n` 回以上、`m` 回以下出現することにマッチ |

---
##### grepコマンドの使い方

###### grepコマンドの基本的な使い方

grepコマンドは以下のように指定します。

```bash
grep [検索したい文字列] [検索するファイル]
```

###### 簡単な検索をやってみよう

[シミュ](https://terminal.engineer-ninaritai.com/)[レーター](https://terminal.engineer-ninaritai.com/)を使って実践してみましょう。

今回は、testという文字列を検索したい場合を想定します。

まず、**テキストファイルを作成しましょう**。以下のコマンドを実行します。

```bash
echo test1234 > file.txt
echo abcd1234 >> file.txt
```

コマンドを入力したら、catコマンドでfile.txtの中身を見てみましょう。

```bash
cat file.txt
```

すると、以下のように2行のテキストデータができます。
![[Pasted image 20250903193233.png]]

次に、**testという文字列があるのか検索してみましょう。**

```bash
grep test file.txt
```

ファイルを実行すると、以下のように”test1234″と表示されます。

###### 正規表現を使って検索

**grepコマンドで正規表現を使って検索する場合は、”-E”オプションを使用しましょう。**

例えば、数字が含まれているかどうかを検索してみましょう。

```bash
grep -E [1-9] file.txt
```

コマンドを実行すると、数字が含まれた行が表示されます。
![[Pasted image 20250903193403.png]]

###### 検索にマッチした部分だけ抜き出す

grepコマンドを実行すると、検索にマッチした行を表示します。

マッチした部分だけを抜き出す場合は、”-o”オプションを使用します。

```bash
grep -o -E [1-9] file.txt
```

コマンドを実行すると、正規表現にマッチした部分、つまり数字だけを抜き出します。
![[Pasted image 20250903193446.png]]

###### ディレクトリの下層まで検索する

grepコマンドは、ディレクトリを指定することができます。

例えば、testdirディレクトリの中にfile1.txtとfile2.txtがあるとします。

この時、”-r”オプションを使うと、testdirディレクトリに入っているファイルの中を検索します。

試してみましょう。

まず、ディレクトリとファイルを作成します。

```bash
mkdir testdir
echo test1234 > testdir/file1.txt
echo test1234 > testdir/file2.txt
```

その後、grepコマンドを-rオプションをつけて実行します。

```bash
grep -r test testdir
```

コマンドを実行すると、testdirディレクトリ配下のファイルを検索してくれます。
![[Pasted image 20250903193646.png]]

その後、grepコマンドを-rオプションをつけて実行します。

```bash
grep -r test testdir
```

コマンドを実行すると、testdirディレクトリ配下のファイルを検索してくれます。
![[Pasted image 20250903194616.png]]

###### その他のオプション

grepコマンドその他のオプションはこちらです。

| オプション        | 説明                          |
| ------------ | --------------------------- |
| -i           | 大文字小文字を無視して検索する             |
| -v           | パターンに一致しない行を表示する            |
| -c           | パターンに一致する行の数を表示する           |
| -l           | パターンに一致する行を含むファイル名を表示する     |
| -n           | パターンに一致する行の行番号を表示する         |
| -r, -R       | サブディレクトリ内のファイルも再帰的に検索する     |
| -w           | パターンと完全に一致する単語を検索する         |
| -A <N>       | パターンに一致した行の後に<N>行を表示する      |
| -B <N>       | パターンに一致した行の前に<N>行を表示する      |
| -C <N>       | パターンに一致した行の前後に<N>行を表示する     |
| -E           | 拡張正規表現を使用する (GNU grep)      |
| -F           | パターンを固定文字列として解釈する           |
| -P           | Perl互換の正規表現を使用する (GNU grep) |
| -o           | パターンに一致する部分のみを表示する          |
| –exclude     | 特定のパターンを持つファイルを検索から除外する     |
| –include     | 特定のパターンを持つファイルだけを検索対象にする    |
| –exclude-dir | 特定のディレクトリを検索から除外する          |
| –color       | パターンに一致した部分を色付けして表示する       |

---
##### コマンドの実行結果を検索する方法

###### コマンドを同時に実行する

grepコマンドは、その他のコマンドと同時実行することで、そのコマンドの出力結果を検索することができます。

例えば、lsコマンドを実行したとします。

```bash
ls /etc
```

コマンドを実行すると、以下のように/etcディレクトリ配下の情報が全て表示されます。
![[Pasted image 20250903194752.png]]

grepコマンドを同時に実行させることで、この中から特定のファイルだけ検索することができます。

例えば、lsコマンドとgrepコマンドを組み合わせて”conf”という文字が含まれたファイルだけを出力させてみましょう。

以下のように実行します。

```bash
ls /etc | grep conf
```

すると、以下のようにconfという文字列にマッチした部分だけ表示されます。

![[Pasted image 20250903194823.png]]

このように、|(パイプ)を使うことで、複数のコマンドを同時に実行できます。

lsコマンド以外にも、さまざまなコマンドとgrepコマンドは組み合わせることが可能です。

---
##### セミコロンで順次実行

**セミコロン(;)を使うと、複数のコマンドを順番に実行できます。**

```bash
コマンド1 ;コマンド2
```

セミコロンを使うと、複数のコマンドを順番に実行できます。

一つのコマンドが実行された後、セミコロンの後に続く次のコマンドが実行されます。

**各コマンドの実行は前のコマンドの成功や失敗に関わらず行われます。**

例えば、以下のようなコマンドを実行してみましょう。

[シミュレーターを起動](https://terminal.engineer-ninaritai.com/)してコマンドを入力してみましょう。

```bash
echo Hello ; date; ls -l
```

このコマンドは、次の順序でコマンドを実行します。

1. **`echo Hello`**: “Hello”というテキストを表示します。
2. **`date`**: 現在の日時を表示します。
3. **`ls -l`**: カレントディレクトリの内容を詳細なリスト形式で表示します。

実行すると、以下のように表示されます。
![[Pasted image 20250903194941.png]]

それぞれのコマンドは前のコマンドの成功や失敗に影響されずに、順番に実行されます。

普段はあまり使用しませんが、シェルスクリプトを作成する時などに使用します。

---
##### &&(アンパサント2個)で実行が成功したら順次実行

&& (アンパサント2個)でコマンドの実行が成功したら、次のコマンドを実行することができます。

```bash
コマンド1 && コマンド2
```

“`コマンド1 && コマンド2` “の形式は、`コマンド1` が成功した場合にのみ `コマンド2` を実行します。

もし `コマンド1` の実行が失敗すると、`コマンド2` は実行されません。

具体的な例を見てみましょう。

[シミュレーターを起動](https://terminal.engineer-ninaritai.com/)してコマンドを入力してみましょう。

以下は、２つのコマンドの実行が成功する例です。

```bash
echo Hello && echo World
```

このコマンドは、echo”Hello”というコマンドを実行し、成功したら次に echo “World” を実行します。  
echoコマンドは常に成功するので”Hello”が表示された後、次に”World”が表示されます。
![[Pasted image 20250903195029.png]]

一方、次の例では失敗するコマンドをやってみましょう。

```bash
ls hogehoge && echo hoge
```

この場合、ls hogehogeは存在しないディレクトリをリストしようとするため、失敗します。  
そのため、echo hogeは実行されません。
![[Pasted image 20250903195041.png]]

つまり、&&の右側のコマンドは、左側のコマンドが成功した場合にのみ実行されるということがわかります。

---
###### パイプでコマンドの出力を次に渡す

パイプ（|）を使うことで、コマンドの出力を次に渡すことができます。

```bash
[コマンド1] | [コマンド2]
```

コマンド1 | コマンド2 の形式は、パイプ（|）を使って、コマンド1 の出力を コマンド2 の入力として渡します。

これにより、複数のコマンドを連続して実行し、処理を行うことができます。

具体的な例を見てみましょう。

[シミュレーターを起動](https://terminal.engineer-ninaritai.com/)してコマンドを入力してみましょう。

```bash
ls -l /etc | grep init
```

このコマンドは、まず ls -l コマンドを実行してカレントディレクトリの内容を詳細なリスト形式で表示します。  
その出力をgrep initコマンドに渡して、”init”を含む行を検索します。つまり、ディレクトリ内のinitという文字列が含まれているファイルのみを表示します。
![[Pasted image 20250903195140.png]]

このようにパイプ（|）とgrepコマンドを使うことで、効果的にコマンドを利用できます。

---
##### ||(パイプ2個)で実行が失敗した場合に順次実行

続いては、パイプ2個でコマンドの実行が失敗した場合に次のコマンドを実行する方法です。

```bash
コマンド1 || コマンド2
```

コマンド1 || コマンド2の形式は、コマンド1が失敗した場合にのみコマンド2を実行します。  
もしコマンド1の実行が成功すると、コマンド2は実行されません。

具体的な例を見てみましょう。

[シミュレーターを起動](https://terminal.engineer-ninaritai.com/)してコマンドを入力してみましょう。

```bash
ls hogehoge || echo DirectoryNotFound
```

このコマンドは、ls hogehogeを実行して存在するディレクトリをリストしようとします。

もしhogehogeが存在する場合、ls コマンドは成功し、echo コマンドは実行されません。

逆に、もしディレクトリが存在しない場合、ls コマンドが失敗し、その後の echo コマンドが実行されて “DirectoryNotFound” が表示されます。

![[Pasted image 20250903195237.png]]

このテクニックは、一つのコマンドが失敗した場合に代替の処理を行いたい場合に有用です。

条件に応じて異なるコマンドを実行する際に使用できます。

---
##### コマンドの連続実行まとめ

ここまで、コマンドの連続実行について解説しました。

まとめると、以下のようにになります。

| コマンド             | 説明                                     |
| ---------------- | -------------------------------------- |
| `コマンド1 ; コマンド2`  | `コマンド1` を実行し、その後すぐに `コマンド2` を実行します。    |
| `コマンド1 && コマンド2` | `コマンド1` を実行し、成功した場合にのみ `コマンド2` を実行します。 |
| `コマンド1 \| コマンド2` | `コマンド1` の出力を `コマンド2` の入力として渡します。       |
| `コマンド1 \| コマンド2` | `コマンド1` を実行し、失敗した場合にのみ `コマンド2` を実行します。 |

